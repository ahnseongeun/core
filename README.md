##스프링 컨테이너 생성

- 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다.
    - new AnnotationConfigApplicationContext(AppConfig.class)
    - AppConfig.class가 구성 정보
    
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다.

## 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다.
    - 기존 싱글톤 패턴의 문제점
    1. 싱글톤 작성 코드가 길어진다.
    2. 클래스 내부에서 객체를 직접 생성하기 때문에 OCP, DIP 위반
    3. 테스트가 어렵다.
- 스프링 컨테이너는 싱글톤 객체를 생성하고, 관리하는 기능을 하며 지저분한 코드가 들어가지 않아도 되고,
DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.
  
## 싱글톤 방식의 주의점
- 싱글톤 방식은 객체 인스턴스를 하나만 생성해서 공유하는 방식이기 때문에 여러 클아이언트가
하나의 같은 객체 인스턴스를 공유한다. 그래서 싱글톤 객체는 상태(stateful)를 유지하게 설계하면 안된다.
    - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
    - 가급적 읽기만 가능해야 한다.
    - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용
    
## @Configuration와 싱글톤
- @Configuration에서 @bean으로 등록된 객체가 다른 @bean에서 해당 bean을 호출했을 때
bean을 호출할 때마다 new가 사용되는데 스프링은 어떻게 싱글톤 보장을 하는 것일까??
  
- AnnotationContextApplicationContext에 파라미터로 넘긴 값은 스프링 빈으로 등록된다. 그래서
AppConfig도 스프링 빈이 된다.
  - 원래는 class hello.core.AppConfig가 등록되어야 하지만 xxxCGLIB가 붙으면 복잡해진다. 이렇게 된 이유는
  내가 만든 AppConfig가 등록되는 것이 아니라 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를
    상속받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것이다!
  - 이 상속받은 임의의 클래스가 싱글톤이 보장되게 해준다.
  - @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환한다.
  - AppConfig@CGLIB는 AppConfig의 자식 타입이므로, AppConfig 타입으로 조회 할 수 있다.
  
- 그러면 @Configuration을 적용하지 않고, @Bean만 적용하면 어떻게 될까?
  - 그러면 우리가 만든 Class가 Bean으로 등록된다. 그러면 @Configuration은 왜 사용하는 것인가?
  - Bean을 호출 할 때 파라미터로 Bean으로 등록된 Class를 주입할 때 new로 넣기 때문에 의존 관계가 있는 싱글톤이 깨진다.
    - 즉, 의존 관계 관련에서 Bean을 생성 할 때 같은 새로운 new instance로 주입된다. 그리고 스프링 컨테이너가 싱글톤을 보장하지 않는다.
  
## 컴포넌트 스캔과 의존관계 자동 주입 시작하기
- 스프링 빈을 등록할 때 자바 코드의 @Bean이나 XML의 <bean> 등을 통해서 설정 정보를 직접 등록할 스프링 빈을 나열했다.
  - 직접 Bean을 관리하다보면 누락할 일도 생기고 관리도 복잡해 진다.
  - 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
  - 또한 의존 관계도 자동으로 주입하는 @Autowired라는 기능도 제공한다.
  - @ComponentScan은 이름 그대로 @Component 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
  - 이전의 AppConfig에서는 @Bean을 이용해서 사용자가 직접 의존관계를 작성했다. 하지만 이제는 구현체에 @Component와 의존관계가 필요한 클래스에 @Autowired
  라는 애노테이션을 통해서 더 간단하게 Bean들을 관리 할 수 있다.
    
- basePackages로 탐색할 package를 정할 수 있다.
  - 그럼 default는 무엇인가?? 해당 Config의 붙은 package를 기준으로 탐색한다. 그래서 Config 즉, 설정 파일을 프로젝트 최상단에 두는 방법이 있다. 
  - SpringBootApplication에 Component가 기본으로 들어있다.
  - ComponentScan은 Component, Controller, Service, Repository, Configuration도 추가로 대상에 포함한다.
  - 애노테이션은 상속관계라는 것이없다. 애노테이션이 특징 애노테이션을 들고 있는 것을 인식할 수 있다는 것은 자바 언어가 지원하는 기능이 아니라 스프링이 지원하는 기능이다.
  

    
